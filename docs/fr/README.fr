============================================================================
                                ettercap 0.6.0                    17/09/2001
============================================================================

    Meme s'ils sont dotés d'une faible intelligence ils sont cruels et rusés...

       @@@@@@@ @@@@@@@ @@@@@@@ @@@@@@@ @@@@@@@ @@@@@@@ @@@@@@@ @@@@@@@
       @@        @@@     @@@   @@      @@   @@ @@      @@   @@ @@   @@
       @@@@@@    @@@     @@@   @@@@@@  @@@@@@  @@      @@@@@@@ @@@@@@
       @@        @@@     @@@   @@      @@  @@  @@      @@   @@ @@
       @@@@@@@   @@@     @@@   @@@@@@@ @@  @@@ @@@@@@@ @@   @@ @@


                     sniffer/intercepteur multi-usage


        Bibliothèques nécessaires  :    aucune ;)  (éventuellement ncurses 4.2)

        Bibliothèques optionnelles :    openssl (si vous voulez le support ssh)

        Installation:                   configure
                                        make
                                        make install

                      (optionnel)       make plug-ins
                                        make plug-ins_install

        (si vous etes paresseux
         faites seulement ceci)         make complete_install

============================================================================
                                    INTRO
============================================================================

gamin:  Un de amis m'a dit qu'il était possible de sniffer sur un LAN,
        j'ai donc acheté un switch ;)

NaGor:  mmhhh...

gamin:  Maintenant mon LAN est SECURISE ! Vous ne pouvez pas intercepter
        mes paquets... ah ah ah

NaGor:  Es-tu sur ? Regarde ettercap fonctionner...

gamin:  Oh mon Dieu... il espionne tout mon trafic !! Je vais utiliser
        seulement des connexions cryptées sur mon LAN, pour que ettercap
        ne puissent pas les intercepter ! ah ah ah

NaGor:  mmhhh...

gamin:  Maintenant j'utilise SSH. Mon LAN est SECURISE !

NaGor:  Es-tu sur ? Regarde ettercap fonctionner...

gamin:  Merde !! grrr...


"un sentiment de sécurité illusoire est pire que l'insécurité"
                                                       -- Steve Gibson

 Ouhouh les gars... réveillez vous ! Le réseau n'est PAS sécurisé !!

 ettercap prouve qu'il est maintenant temps d'encourager les recherches sur
 les protocoles internet pour les rendre plus sur.

============================================================================
                                   LICENCE
============================================================================

   GNU GENERAL PUBLIC LICENSE.

   voyez COPYING pour les détails...


============================================================================
                                   AUTEURS
============================================================================

   Alberto Ornaghi (ALoR) <alor@users.sourceforge.net>

   Marco Valleri (NaGA) <crwm@freemail.it>


============================================================================
                              TABLE DES MATIERES
============================================================================


   1. AVERTISSEMENT.........................................sez.  1

   2. INSTALLATION..........................................sez.  2

   3. UTILISATION...........................................sez.  3

      3.1   avec l'interface ncurses
      3.2   en ligne de commande

   4. DEPANNAGE.............................................sez   4
                 certains problèmes commun résolus (LISEZ CECI AVANT DE
                 NOUS ENVOYER UN MAIL)

   5. EXPLICATIONS TECHNIQUES...............................sez   5

      5.1   la liste des hôtes
      5.2   sniffing IP
      5.3   sniffing MAC
      5.4   sniffing ARP
         5.4.1    corruption arp
                5.4.1.1 public arp
                5.4.1.2 public arp intelligent
         5.4.2    insertion de caractères
         5.4.3    dissection active de protocole
         5.4.4    intercepteur SSH1
         5.4.5    filtrage de paquet
      5.5   scan passif
         5.5.1    identification passive de systèmes d'exploitation
         5.5.2    ports ouverts
         5.5.3    passerelles et routeurs

   6. PLUG-INS..............................................sez.  6

   7. INFORMATIONS INUTILES.................................sez.  7


============================================================================
1>                           AVERTISSEMENT
============================================================================

 Ce logiciel est fourni "comme tel" et sans aucune garantie explicite ou
 implicite, y compris, sans limitation, les garanties implicites de
 commercialisation ou d'adaptation dans un but spécifique


============================================================================
2>                              INSTALLATION
============================================================================

 La façon la plus facile de compiler ettercap est:

    ./configure

    make

    make install

 Vous devriez à ce stade pouvoir lancer ettercap (il s'installe par défaut
 dans le répertoire /usr/local/bin)
 Il y a beaucoup d'options utiles dans configure : essayer d'utiliser --help

 Si vous désirez utiliser ettercap avec le bit suid, permettant ainsi à
 d'autres utilisateurs que root de lancer le programme, utilisez
 --enable-suid avant de changer les droits d'ettercap avec chmod, sinon il
 ignorerait le bit suid.

 Si vous avez des problèmes avec les plug-ins, désactivez les en utilisant
 l'option --disable-plugins

 Si OpenSSL est installé dans un autre répertoire DIR, utilisez
 --with-openssl=DIR. Si vous obtenez une erreur en éditant les liens entre
 OpenSSL et ettercap, essayez de le recompiler avec

    Config shared && make && make install
   (sur ma machine ça a fonctionné;) )

 Si vous avez toujours des difficultés, envoyez un e-mail à un des auteurs
 (alor@users.sourceforge.net or crwm@freemail.it).
 La page officiel d'ettercap chez sourceforge peut aussi contenir des
 informations utiles, les dernières corrections de bug et les versions mises à
 jour (http://ettercap.sourceforge.net).

 Les comptes-rendus de bug sont les bienvenus. Veuillez s'il vous plait
 signaler les problèmes de compilation (configure/make) en incluant une
 copie de config.status, config.cache et config.log, de meme des informations
 pertinentes de diagnostic du compilateur. Si vous rencontrez des problèmes
 avec le programme lui-meme, compilez le avec l'option --enable-debug et
 envoyez aussi une copie de ettercap_debug.log et une description courte de
 votre configuration (ex: version du kernel et de la glibc) en présence
 d'un sigfault ou d'un autre comportement étrange.


============================================================================
3>                            UTILISATION
============================================================================

 Il y a deux principales interfaces disponibles, toutes les deux en mode
 texte, l'une avec une interface ligne de commande {plain b/w character},
 et l'autre avec ncurses avec fenetres colorées pour le plaisir des yeux!

3.1 AVEC L'INTERFACE NCURSES

 Commençons par vous montrer cette dernière :
 Si ettercap est invoqué sans option (voir plus bas pour les options en ligne
 de commande), il lancera l'interface ncurses (après éventuellement un court
 délai, du à l'exploration de votre LAN =).
 La fenetre principale est divisée en trois sous-sections : haut, milieu et
 bas.
 Dans la fenetre du haut se trouve un diagramme de connexion, affichant les
 deux machines à sniffer ou à connecter et sur lesquelles opérer.
 En dessous se trouve la liste de tous les hôtes connus sur le LAN courant
 (avec un hub ou un switch) : choisissez un couple à sniffer.
 Les deux colonnes identiques vous permettent de choisir le dit-couple :
 dans la partie gauche choisissez avec les touches fléchées une entrée
 représentant l'adresse IP d'une machine active ([Entrée] validera votre
 choix).
 Ensuite passez dans la colonne de droite avec [Tab], et déplacez vous
 comme précédemment pour sélectionner la deuxième adresse IP. Cela représente
 la "route" du trafic que vous voudriez espionner (et éventuellement connecter/
 corrompre).
 Vous ne pouvez bien sur pas sélectionner la meme source et la meme
 destination, mais vous n'etes jamais obliger de sélectionner votre propre
 adresse IP.
 Dans la fenetre du bas se trouve une sorte de barre de status, vous donnant
 des informations complémentaires concernant les objets sélectionnés, le
 status courant et d'autres informations utiles.
 Il y a aussi un grand nombre d'autre options géniales sélectionnables à ce
 niveau, dont en premier lieu la fonctionnalité 'p', pour plug-in (ce sont des
 fonctionnalité séparées, programmées en dehors de ce projet, comprenant un
 large champ d'applications, qui ne peuvent etre décrites ici : le fichier
 REAME-PLUGIN est là pour ca).
 A ceci s'ajoute la possibilite d'inspecter avec la touche 'c' s'il y a un
 autre "méchant" programme en route sur votre LAN, vous alertant ainsi d'une
 possible interception de données.
 Souvenez vous néanmoins qu'à travers toutes les étapes du programme vous
 pouvez toujours utiliser la touch 'h' pour aide (help), et une gentille
 fenetre d'aide vous montrera un liste des touches disponibles!

 Les fenetres devraient de toute facon etre claires d'elle-memes, il n'y a
 donc problablement aucun interet à lire ces sections, mais... au cas où.
 Vous remarquerez que la fenetre du haut se met à jour lorsque vous choisissez
 l'adresse IP source et destination, et indique finalement le status courant
 si vous connectez ou sniffez (en pressant respectivement 'a' et 's' ou 'm').
 Le sniffing IP filtre les connexions en observant l'en-tete IP pour
 rechercher les adresses IP intéressantes. C'est la bonne vieille méthode
 classique utilisée par la plupart des programmes.
 Le sniffing MAC filtre les connexions en observant l'en-tete ethernet pour
 rechercher les adresses MAC. C'est utile si vous voulez sniffer des
 connexions à partir de votre machine vers un hôte distant à travers une
 passerelle (en sélectionnant simplement votre machine comme source et la
 passerelle comme destination).
 Finalement, il y a l'option connect qui vous permet, si vous ordinateur est
 connecté à un LAN switché, de corrompre le cache ARP, et ainsi de
 sniffer le traffic sur votre réseau local comme si vous étiez sur un
 réseau avec un hub.
 Avec cette option vous pouvez spécifier un ou deux hôtes. Si vous ne
 selectionnez qu'un seul hôte vous entrerez dans le mode PublicARP et vous
 substituerez votre adresse IP à l'adresses IP selectionnée.
 Si vous spécifiez deux hôtes, vous entrerez dans le mode ARPBased qui vous
 permet d'observer tout le trafic bidirectionnel entre les deux hôtes.

  LISTE DES CONNECTIONS :

 Dans tous les cas, vous pouvez maintenant accéder à la deuxième étape : la
 fenetre centrale principale affiche la liste des toutes les connexions
 actives entre les deux adresses IP, s'il y en a.
 Finalement les connexions ouvertes ressortent, et vous pouvez les
 selectionner comme d'habitude, ce qui vous permet d'accéder à la troisième
 étape : le vrai sniff! =)
 Dans ce mode vous pouvez de toute facon regarder le status des connexions
 (actives, fermées, etc) et voir quel type de trafic/port est utilisé (ftp,
 ssh, web, etc).
 Il est aussi possible de tuer une connexion active, quel que soit son type.
 Si le protocole de niveau application est supporté par ettercap vous pouvez
 voir, dans la fenetre du bas, des informations utiles concernant la connexion
 sélectionnée, comme le USER et le mot de passe utilisés pour les sessions
 interactives.
 Si vous avez utilisé le mode ARPBased, vous pouvez aussi lancer la DISSECTION
 ACTIVE DE PROTOCOLE (ACTIVE PROTOCOL DISSECTION), qui vous permet d'espionner
 certains protocoles cryptés comme ssh.

 USINE A PAQUET :

 A l'aide de la touche 'x' vous pouvez créer vos propres paquets, de la couche
 ethernet à la couche application. Par défault les champs du formulaire de
 l'usine à paquet sont remplis par les propriétés de la connexion courante.
 On peut procéder de la meme maniere avec la liste des hôtes (premiere
 interface) mais maintenant les champs ne se complètent pas automatiquement si
 vous ne sélectionnez pas un hôte cible. Tous les champs peuvent etre modifiés
 comme vous voulez et pour les protocoles non supportés, il est possible de
 construire un en-tete à partir d'une chaine hexadécimale.
 ex: Supposons que nous voulons générer un paquet RIP:
     nous remplissons le formulaire de l'entete UDP (port 520) et dans le
     champ données nous écrivons
       "\x01\x02\x00\x00\xFF\xFF\x00\x02here the pass"
     nous avons généré l'en-tete RIP à l'aide de séquences hexadécimales...

 SNIFFING

 Supposons maintenant que vous avez selectionné une connexion active: deux
 sous-fenetres apparaissent dans la fenetre principale. Elles vous montrent les
 paquets source traversant votre ordinateur avant d'atteindre leur destination,
 vous sniffez le trafic sans qu'ils le remarquent! Il y a plusieurs options de
 visualisation : le type de flux peut etre hexadécimal (touche 'x') ou ascii
 (touche 'a'), type qui est décodé spécifiquement pour les protocoles
 supportés; certains décodeurs nécessites l'activation de la DISSECTION ACTIVE
 DE PROTOCOLE. Vous pouvez aussi suspendre le flux de données (en empechant
 seulement leur visualisation, car en réalité elles traversent votre ordinateur
 sans que vous le voyiez, en utilisant une sorte de 'scroll-lock' (touche 's'),
 pour une meilleur analyse des données.

 Pour finir, il y a aussi une fonctionnalité tres utile : INJECT.

 En appuyant sur la touche 'i' vous pouvez aussi insérer des caractères
 dans le trafic, en choisissant la direction, et ainsi en ajoutant des
 commandes dans le flux (i.e vous pourriez sniffer une session telnet tout en
 ajoutant des commandes vers le serveur telnet, comme ls ou une quelque autre
 commande, et elles auront un effet exactement équivalent à celui des commandes
 provenant de la machine source. De la meme maniere vous pourriez créer de
 faux messages pour le client qui ne correspondent pas au flux réel).
 NOUVEAU : l'injecteur supporte maintenant des séquences d'échappement. Vous
           pouvez donc faire des injections sur plusieurs lignes.
 NOTE    : rappelez vous de terminer votre injection par les caractères '\n\r'
           si vous désirez injecter des commandes au serveur.

 Le dernier mais non des moindres, le FILTRAGE DE PAQUET:

 Avec la touche 'f', un formulaire est affiché vous demandant de configurer
 un filtre. Faites attention à la fenetre active à ce moment, car les filtres
 source et destination sont différents.
 Vous pouvez donc configurer un filtre qui recherche une chaine particulière
 (meme hexadécimale) dans le champ données TCP ou UDP, et la remplacer par
 la votre ou supprimer le paquet en entier.

 Les commandes disponibles durant la saisie du formulaire sont:

  F10 ou ESC -- sortir du formulaire
  ^N         -- champ suivant                ^P    -- champ précédent
  Home       -- premier champ                End   -- dernier champ
  ^L         -- champ à gauche               ^R    -- champ à droite
  ^U         -- champ au dessus              ^D    -- champ en dessous
  ^W         -- mot suivant                  ^B    -- mot précédent
  ^S         -- début du champ               ^E    -- fin du champ
  ^H         -- effacer le caractère courant ^Y    -- effacer la ligne
  ^G         -- effacer le mot courant
  ^C         -- effacer jusqu'à la fin de la ligne
  ^K         -- effacer jusqu'à la fin du champ
  ^X         -- effacer le champ
  ^] or Ins  -- passer en mode insertion

 Pour une explication détaillée de "comment filtrer une connexion", reportez
 vous à la section 5.4.5

 Il y a aussi une option pour logguer tous ces magnifiques flux de données dans
 un fichier, en pressant simplement la touche 'l', pour le lire plus tard ou
 utiliser un script pour le filtrer à tete reposée.
 Vous pouvez aussi configurer le filtre avec la règle "Log" et seuls les
 paquets correspondants aux critères seront archivés dans le fichier.

 Comme vous le remarquerez, pour utiliser cet outil en mode visuel il sera
 plus simple d'essayer plutot que de lire ces instructions.. L'aide ('h')
 est aussi une ressource sur laquelle compter en l'utilisant.

3.2 EN LIGNE DE COMMANDE

 En fait il y a deux commandes classiques pour obtenir la référence des
 commandes: lancer ettercap avec l'option --help et visualiser notre page man
 (man ettercap ;).
 -> certaines fonctionnalités sont disponibles seulement avec l'interface
    visuelle
      - usine . paquets
      - injection
      - filtrage de paquets

 Meme en lancant le mode non interactif ( -N ) il existe des fonctionnalités
 destinées au mode interactif : vous pouvez activer une petite ligne d'aide
 et changer le mode de visualisation à la volée (entre le mode hexadécimal et
 le mode ascii par exemple). De la meme maniere, il est possible de configurer
 un grand nombre d'options à partir de la ligne de commande et de les trouver
 deja lancées dans le mode interactif.

 Il existe maintenant une possibilité pour réduire l'usage des comandes, en
 spécifiant une ou plusieurs machines à sniffer (si vous etes en mode
 silencieux on peut aussi en spécifier une ou aucune à l'aide de l'option -z :
 comme sniffit qui sniff tout =)

 Ex:

  ettercap -Nsz  (sniffe les données provenant de toutes les IPs)

  ettercap -NCsz  (récupère seulement les users et password de toutes les IPs)

  ettercap -NCsz ghibli meltemi (récupère seulement de "ghibli" vers "meltemi")

 NOTE: si vous aviez lancé ettercap en mode interactif (sans -N) il aurait
       été nécessaire de spécifier l'option 'r' pour rafraichir la liste des
       hôtes IP dans le cas où vous auriez voulu revenir avec 'q' à la première
       interface, car aucune liste n'est produite au début du fait de l'option
       -z
       ex: ettercap -zs ghibli meltemi          ou
           ettercap -zm 00:A0:24:4C:00:F9 00:A0:24:36:00:C2

 Ok, c'est tout.

 Amusez vous et attendez les prochaines version, comprenant le support ssh,
 vous pourriez faire des blagues marrantes à vos amis, surtout s'ils font
 partie de ceux qui croient que ssh est absolument non-sniffable et que son
 cryptage est incrackable, et encore plus s'ils croient aussi que les
 switchs font bien leur boulot.

============================================================================
4>                            DEPANNAGE
============================================================================

 Il y a vraiment un grand nombre de choses qui peuvent vous arriver en
 installant ce programme. Ne nous blamez donc pas en cas d'accidents ou
 d'heures passées en essayant de compiler etc... Pour le moment, jusqu'a
 ce que nous atteignions une version *tres* stable, il n'y aura aucune
 section dépannage, car elle serait trop longue, impossible à écrire et car
 nous nous disperserions trop en beta test.
 Néanmoins nous ferons de notre mieux en essayant de le compiler sur un grand
 nombre de machines, de le porter autant que  possible, et de le rendre propre.
 Pour l'instant la principale orientation a été d'écrire les idées de base et
 de les observer fonctionner. Quand le squelette principal sera complet, il
 y aura un grand nombre de réglages plus fins.

 La meilleure chose à faire si vous avez besoin d'aide pour l'utiliser ou
 pour compiler est de lire le forum du site web d'ettercap. Vous pourrez y
 trouver les solutions courantes pour beaucoup de problèmes.

 Par la suite nous écrirons une sorte de FAQ et une liste des résolutions de
 problèmes ou des choses restantes à faire dans cette section.

VERSION RPM:

 Nous aimerions que vous sachiez qu'il existe des problèmes en particulier
 en installant la version rpm des binaires d'ettercap, avec ncurses, qui peut
 facilement etre mal détecté : essayez simplemnt d'utiliser l'option rpm
 --nodeps.

COMPILER AVEC OPENSSL

 Ettercap nécessite la version liée dynamiquement de OpenSSL donc si vous
 rencontrez un problème lors de l'édition de liens d'ettercap essayez de
 recompiler OpenSSl avec:

 "config shared && make && make install"

 puis éditez le fichier /etc/ld.so.conf et ajoutez y le chemin de la librairie
 et lancer "ldconfig"

LANCEMENT TROP LENT :

 si le message "Building host list for netmask 255.255.255.0, please wait..."
 s'affiche pendant plus de 5-10 secondes, il est probable que votre
 gethostbyaddr() soit trop lent à résoudre les noms, donc essayez de lancer
 ettercap avec -d, cette option empeche la résolution des IPs.


============================================================================
5>                   EXPLICATIONS TECHNIQUES
============================================================================

5.1   LA LISTE DES HOTES

 Quand ettercap démarre il crée la liste des machines présentes sur le LAN.
 Il est possible en envoyant un paquet ARP REQUEST pour chaque IP du LAN
 (trouvée à partir de l'adresse IP courante et du masque de sous-réseau) d'
 obtenir un ARP REPLY et donc d'établir la listes des hôtes qui répondent
 sur ce LAN. Avec cette méthode meme les hôtes windowsiens répondent à
 l'appel (ils ne répondent pas ping broadcast).
 Soyez tres attentif si le réseau est de classe B (255.255.0.0) car ettercap
 envoiera alors 255*255 = 65025 ARP REQUESTS, ce qui prend plus d'une minute !!
 (le délai entre deux requetes est de 1 milliseconde).

5.2   SNIFFING IP

 C'est la "bonne vieille" méthode de sniffing.
 Il place l'interface réseau en mode "écoute" (promiscous) et sniffe alors
 tous les paquets à travers le filtre IP.
 Si vous utiliser l'interface ncuses, le filtre IP est constitué de: l'adresse
 IP source, le port source, l'adresse IP destination, le port destination;
 ceci dans les deux directions de la connexion.
 A la place si vous utiliser la ligne de commande, vous pouvez personnaliser
 le fitre IP. Vous pouvez ne spécifier que la source, que la destination ou
 les deux, en précisant ou pas un port associé.

   Exemples:

     ettercap -N -s ghibli
     ettercap -N -s ghibli:23

  le premier exemple sniffera toutes les connexions de l'hôte "ghibli"
  le second sniffera seulement celle sur le port 23

     ettercap -N -s ghibli meltemi
     ettercap -N -s ghibli:23  meltemi
     ettercap -N -s ANY:23

  le premier sniffera toutes les connexions entre "ghibli" et "meltemi"
  le deuxième seulement celles sur ghibli:23 provenant de "meltemi"
  le troisième sniffera tous les hôtes mais seulement sur le port 23 (telnet)


5.3    SNIFFING MAC

 Cette méthode place l'interface réseau en mode promiscous et sniffe ensuite
 tous les paquets à travers le filtre mac.
 Le filtre mac est constitué à partir de l'adresse IP des deux hôtes.
 Ettercap scannera la liste des hôtes et associera les bonnes adresses MAC
 pour le filtre. De cette facon vous pouvez spécifier l'adresse IP de la
 passerelle et celle de l'hôte, et vous obtiendrez toutes les connexions
 entre l'hôte et Internet

     Exemples:

   en supposant que "meltemi" est la passerelle vers Internet.

     ettercap -N -m ghibli meltemi

   ceci retournera toutes les connexions que "ghibli" établit avec des hôtes
   distants

5.4   SNIFFING ARP

 Cette méthode ne place pas l'interface en mode écoute. Ce n'est pas
 nécessaire car les paquets nous sont envoyés! :) Le switch va nous
 forwarder les paquets, et nous avons donc une bonne méthode pour
 sniffer sur les LAN switchés.
 Regardons comment c'est possible:
 Quand vous sélectionnez cette méthode, ettercap corrompt le cache arp des
 deux hôtes, en s'identifiant lui-meme comme l'autre hôte (voir section
 suivante pour ceci).
 Une fois que les caches arp sont corrompus, les deux hôtes commencent la
 connexion, mais leurs paquets nous seront envoyés, et nous les
 enregistrerons puis les envoyerons à leur destinataire. La connexion
 est donc transparente aux victimes, qui ne peuvent affirmer qu'ils sont
 sniffés. La seule méthode pour découvrir qu'il y a un intercepteur
 dans la connexion est de regarder le cache arp et de vérifier s'il n'y
 a pas deux hôtes (ndt:deux adresses IP) avec la meme adresse MAC.
 C'est ce que nous faisons pour découvrir s'il y a d'autres corrupteurs
 de caches ARP sur notre réseau, pour etre prévenu que notre trafic est sous
 controle! =)

     HOST 1  - - - - - - - - - - - - - - - - - - - -> HOST 2
   (corrompu)                                      (corrompu)
       |                                               ^
       |                                               |
        ------------> ATTACKER HOST  ------------------
                      ( ettercap )


 Legende:
             - - - ->   la connexion logique (théorique)
             ------->   la connexion réelle

 OK, cool! Maintenant, comment je peux corrompre le cache ARP ?


5.4.1    CORRUPTION ARP

 Le protocole ARP contient un trou de sécurité intrinsèque. Dans le but de
 réduire le trafic sur le cable, il insert une entrée dans le cache meme
 s'il n'a rien demandé. En d'autres termes, TOUTES les réponses ARP
 envoyées sur le support seront insérées dans la table ARP.
 Nous profitons donc que cette "caractéristique", en envoyant des fausses
 réponse ARP aux deux hôtes que nous voulons sniffer. Dans cette réponse,
 nous affirmons que l'adresse MAC du second hôte est celle de NOTRE carte
 ethernet. Le premier hôte va donc nous envoyer les paquets destinés à son
 vis-à-vis, puisqu'ils contiennent notre adresse MAC.
 Le meme procédé est appliqué pour le premier hôte, dans manière inverse,
 et nous avons donc une connexion interceptrice parfaite entre les
 deux hôtes, recevant "légalement leurs paquets"!!

    Exemple:

     HOTE 1:  mac: 01:01:01:01:01:01         HOST ATTAQUANT:
               ip: 192.168.0.1                    mac: 03:03:03:03:03:03
                                                   ip: 192.168.0.3

     HOTE 2:  mac: 02:02:02:02:02:02
               ip: 192.168.0.2


   nous envoyons des réponses ARP à:

           HOST 1 en affirmant que 192.168.0.2 correspond à 03:03:03:03:03:03
           HOST 2 en affirmant que 192.168.0.2 correspond à 03:03:03:03:03:03

   et alors ils sont corrompus !! Ils nous envoierons leurs paquets !
   Si notre machine recoit des paquets de:

           HOST 1 nous les envoyerons à 02:02:02:02:02:02
           HOST 2 nous les envoyerons à 01:01:01:01:01:01

   simple, n'est-ce pas ?

 *** PROBLEME PROPRE A LINUX KERNEL 2.4.x ***

 In the latest relase of linux kernel we can find in :
 /usr/src/linux/net/ipv4/arp.c

 /* Unsolicited ARP is not accepted by default.
    It is possible, that this option should be enabled for some
    devices (strip is candidate)
 */

 le noyau utilise un système spécial de gestion des hôtes voisins pour
 refuser les réponses ARP non sollicitées (que ettercap envoie aux victimes).
 Oh, merde, ettercap est inutile avec ce noyau ? la réponse est NON !
 Voyons pourquoi... dans le même code source nous trouvons :

 /*
 *  Process entry.  The idea here is we want to send a reply if it is a
 *  request for us or if it is a request for someone else that we hold
 *  a proxy for.  We want to add an entry to our cache if it is a reply
 *  to us or if it is a request for our address.
 *  (The assumption for this last is that if someone is requesting our
 *  address, they are probably intending to talk to us, so it saves time
 *  if we cache their address.  Their address is also probably not in
 *  our cache, since ours is not in their cache.)
 *
 *  Putting this another way, we only care about replies if they are to
 *  us, in which case we add them to the cache.  For requests, we care
 *  about those for us and those for our proxies.  We reply to both,
 *  and in the case of requests for us we add the requester to the arp
 *  cache.
 */

 Donc, si le noyau reçoit une REQUETE il enregistera l'information... Ca
 signifie quoi ? si ettercap envoie des REQUETES corrompues au lieu de 
 REPONSES corrompues, le noyau mettra à jour le cache ? La réponse est OUI !!

 ettercap 0.6.0 et suivants utilise cette NOUVELLE METHODE de CORRUPTION de 
 cache. Il enverra alternativement des REQUETES et des REPONSES car d'autres
 OS ne disposent pas de cette "fonctionnalité".


 *** PROBLEME SPECIFIQUE A SOLARIS ***

 Solaris n'enregistrera pas une réponse si elle n'est pas déjà dans le cache.
 L'astuce est simple, avant de corrompre, ettercap envoie un paquet ICMP 
 ECHO_REQUEST spoofé à l'hôte, et celui-ci doit y réponse et il créera une 
 entrée ARP pour l'hôte spoofé. Ensuite nous pouvons commencer comme d'habitude
 l'entrée est desormais dans le cache...

5.4.1.1 PUBLIC ARP

 Pour sniffer les paquets en provenance d'un hôte cible vers tous les autres
 sur un LAN switché, vous devez utiliser le mode PublicARP
 Avec cette méthode ettercap envoie des réponses ARP en broadcast associant
 l'adresse IP de la victime et l'adresse MAC de ettercap (corrompant le cache
 arp).
 Tous les hôtes vont accepter cette réponse et l'ajouter à leur cache, donc
 par la suite ils envoyeront tous les paquets à destination de la victime
 à ettercap.
 Mais, il y a un problème, car meme la victime va recevoir cette réponse et
 remarquera un conflit d'adresse IP (comme c'est le cas pour win2k)
 Pour résoudre ce problème est né le public arp intelligent...

5.4.1.2 PUBLIC ARP INTELLIGENT

 Avec cette méthode les réponses sont envoyées sélectivement à tous les hôtes
 sauf la victime. De cette manière il n'y a aucun conflit.

 NOTE : les hôtes corrompus correspondront à ceux présents dans la liste, donc
 si vous ne voulez pas corrompre un hôte, vous pouvez le supprimer de la liste
 en appuyant sur 'd'.

 NOTE : pour utiliser le public arp intelligent, ettercap doit connaitre la
 liste de hôtes, il est donc préferable que vous n'utilisiez pas le démarrage
 avec ping en broadcast (option -b). Cependant il est impossible d'utiliser
 l'arp intelligent sans la liste lors de l'utilisation du mode silencieux (-z).
 ettercap choisit automatiquement l'option adéquate : s'il dispose de la
 liste, il utilisera l'arp intelligent, sinon, il utilisera la bonne vieille
 méthode public arp.

 NOTE : avec cette méthode, un plus grand nombre de réponses ARP sont
        envoyées sur le LAN

5.4.2   INSERTION DE CARACTERE

 Nous avons affirmé que les paquets sont pour nous...
 Et les paquets ne seront pas reçus par la destination jusqu'à ce que nous
 les renvoyons.
 Mais que se passe-t-il si nous les modifions ?
 Oui, ils atteignent la destination avec nos modifications.
 Nous pouvons modifier, ajouter, supprimer le contenu de ces paquets, en
 recalculant simplement la somme de controle et en les substituant dans le
 trafic.
 Mais nous pouvons aussi faire plus : nous pouvons insérer des paquets dans la
 connexion.
 Nous créeons nos paquets avec le bon numéro de séquence et d'acquittement
 et nous les envoyons à l'hôte désiré. Lorsque les prochains paquets passeront
 par notre machine nous ajoutons ou soustrayons simplement le numero de
 séquence avec la nombre  de paquets que nous avons injecté tant que la
 connexion est ouverte, empechant la connexion d'etre rejetée (ceci jusqu'à
 ce que nous sortions d'ettercap, qui maintient les numéros de séquence
 corrects. Après la sortie du programme, la connexion doit etre "RESETTED"
 ou bien tout trafic futur sera rejetée, bloquant la station source).

 NOTE: l'injecteur supporte les séquences d'échappement. Vous pouvez
       réaliser des injections multi-lignes
       ex: "ceci est la premiere ligne \n voici la deuxième \n etc ..."
       ex: "ceci est en mode hexa: \x65\x6c\x6c\x65"
       ex: "ceci est en mode octa: \101\108\108\101"

 NOTE: souvenez vous de finir votre injection avec \r\n si vous voulez
       injecter des commandes au serveur.

5.4.3 DISSECTION ACTIVE DE PROTOCOLE (pour le mode ARPBASED)

 Pour observer des flux cryptés solidement vous avez besoin d'agir vraiment
 dans le flux. Par exemple il vous faut changer les paquets clés (technique
 de l'intercepteur (ndlt: man-in-the-middle)).
 Dans certains cas particuliers ceci provoquera une faute de protocole, soyez
 donc attentif en utilisant cette fonctionnalité.
 La méthode utilisée change de protocole en protocole et est plus difficile
 à expliquer qu'à coder.
 Je suis donc désolé mais vous devrez examiner le code source si vous voulez
 vraiment comprendre comment ça marche.

5.4.4 INTERCEPTEUR SSH1

 Lorsqu'une connexion démarre (souvenez vous que nous somme le "maitre des
 paquets", tous les paquets passent par ettercap) nous substituons une clé
 générée à la volée à la clé publique du serveur, que nous sauvegardons dans
 une liste pour que nous puissons nous souvenir que ce serveur a déjà été
 corrompu.  Puis le client envoie le paquet contenant la clé de session
 crypté avec notre clé, et nous somme donc capable de le décrypter et de
 d'obtenir la vrai clé de session 3DES. Maintenant nous cryptons le paquet
 avec la vraie clé publique du serveur et nous l'envoyons au démon SSH.
 La connexion est établie normalement, mais nous avons la clé de session !!
 Maintenant nous pouvons décrypter tout le trafic et observer le flux!
 La connexion restera active meme si nous sortons ettercap, car ettercap
 ne joue pas le role de tampon (comme dsniff). Apres l'échange de clés,
 ettercap est seulement un spectateur... ;)

5.4.5 FILTRAGE DE PAQUETS

  De meme que lors de l'injection de caractère, nous pouvons modifier les
  données des paquets et remplacer les bons numéros de séquence et
  d'acquittement si nécessaire.
  A l'aide du moteur intégré de filtrage vous pouvez programmer votre propre
  chaine de filtrage pour réaliser le filtre le plus adéquat à vos besoins.
  Une chaine de filtrage est un simple tableau de filtres qui peut etre vu comme
  une liste d'instructions d'une machine virtuelle. Le point d'entrée du
  programme est le filtre 0 (zéro). Vous pouvez spécifier un saut à une autre
  "instruction" si le filtre est vrai et un autre saut si le filtre est faux.
  Un filtre est considéré comme vrai si le triplet
  <port source, port destination, données> est égal à celui du filtre
  (évalué à l'aide d'un ET logique). Une chaine de caractères de recherche NULL
  est toujours considérée comme vraie.
  Si le filtre correspond, il exécutera l'action (Log, Replace or Drop) et
  évaluera le saut correct à effectuer. Le "pointeur d'instruction" sera alors
  affecté au filtre concerné. Lorsque la valeur d'un saut est nulle la chaine
  de filtrage est considérée comme terminée et le paquet est envoyé vers l'hôte
  destination.
  Vous pouvez donc configurer un filtre qui recherche une chaine de caractères
  particulières (meme hexadécimale) dans les données TCP ou UDP et la remplacer
  par la votre ou effacer l'ensemble du paquet. Vous pouvez utiliser des
  quantificateurs dans la chaine de caractères de recherche en utilisant la
  notation spéciale [n*] où n est le nombre de caractères à rechercher.
  Par ex.

    supposons un flux de données comme suit :

       paquet 1:   "var1=123&var2=400"
       paquet 2:   "var1=124&var2=420"
       paquet 3:   "var1=125&var2=460"
       paquet 4:   "var1=126&var2=540"
       paquet 5:   "var1=127&var2=700"
       ...
       ...

    nous voulons assigner une valeur à var1 quelle que soit sa valeur courante.
    Nous utilisons alors un filtre comme ceci :

          Search:  "var1=[3*]"
          Replace: "var1=000"

    qui produira une sortie comme ceci :

       paquet 1:   "var1=000&var2=400"
       paquet 2:   "var1=000&var2=420"
       paquet 3:   "var1=000&var2=460"
       paquet 4:   "var1=000&var2=540"
       paquet 5:   "var1=000&var2=700"
       ...
       ...

    et quelles que soient les données qui contiennent un assignation de var1
    il la modifiera à "var1=000".

  NOTE : vous pouvez utiliser les quantificateurs seulement à la fin de la
         chaine de caractères !!
  Par exemple
          "var1=[5*]"             OK
          "[4*]=123"              INTERDIT
          "var1=[3*]&pippo"       SERA TRANFORME EN "var1=[3*]"
          "var1=[3*]&var2=[3*]"   INTERDIT
                                  pour mettre en place un filtre multiple
                                  utilisez un premier filtre qui réalise le
                                  remplacement de var1 accompagné d'un saut
                                  à un second filtre qui fait le second
                                  remplacement.
                                  p.e:  0 | var1=[3*] R var1=000  | => 1
                                        1 | var2=[3*] R var2=111


  Vous pouvez meme rechercher et remplacer des chaines avec caractères
  d'échappement comme "\x72\x6f\x6f\x74".

  NOTE: le formulaire supprime automatiquement les espaces en fin de chaine,
        donc si vous voulez chercher "ettercap ", vous devrez utiliser la
        chaine "ettercap\x20". "\x20" sera remplacé par " ".
        Et si vous voulez rechercher le mot magique "[*]" vous devrez le
        protéger (NdT : 'escape' -> à l'aide du '\')

  NOTE: Si la taille des données remplacées dépasse le MTU légal (du fait que
        vous puissiez remplacer une chaine par une chaine plus longue), le
        filtre échoue silencieusement en laissant les données intactes (la
        vérification est faite avant de remplacer), soyez donc conscient de
        ce que vous filtrez et de la façon dont vous le faites... ;)


5.5 SCAN PASSIF DU RESEAU LOCAL

 Cette fonctionnalité est très utile si vous connaître la topologie du lan
 mais que vous ne voulez pas envoyer de paquets. Avec cette technique le
 scan est réalisé uniquement en sniffant les paquets et en en tirant des
 informations utiles.
 Ce scan vous permettra de connaître les machines sur le lan (il observe les
 requêtes ARP), les systèmes d'exploitations des hôtes (il utilise 
 l'identification passive d'OS... voir prochaine section), les ports ouverts
 (en observant les paquets syn+ack), la passerelle, les routeurs ou les hôtes
 se comportant comme des routeurs (il observe les messages ICMP).
 Du fait que c'est une méthode passive, elle est inutile sur les lan switchés
 (car elle obtient des informations sur les hôtes qui sont connectés 
 directement à vous), mais si vous l'utiliser sur une passerelle et que vous
 la laisser tourner pendant des heures ou des jours, elle produira un rapport
 complet des hôtes sur le lan.


5.5.1 IDENTIFICATION PASSIVE DE SYSTEMES D'EXPLOITATION

 L'idée de base est d'analyser les informations passives provenant d'un hôe
 lorsqu'il initie ou reçoie des connexions avec d'autres hôtes. Ces 
 informations suffisent pour identifier l'OS et les services disponibles.
 Avec cette technique, nous observons les paquets SYN et SYN+ACK et obtenons
 des informations intéressantes à partir de :
 La taille de la fenêtre : le champ dans l'entête TCP
 Le MSS : le champ dans l'entête IP Maximum Segment Size (peut ne pas être 
          présent)
 L'échelle de fenêtre : l'option TCP indicant l'échelle
 SACK : l'option TCP pour le ACK Selectif
 NOP : si les options TCP contiennent un NOP
 DF : le champ de l'entête IP "Don't Fragment"
 TIMESTAMP : si l'option TCP timestamp est utilisée
 et évidemment le type de paquet (syn ou syn+ack)

 La base de données contient des empreintes pour chaque type de paquet car
 certains OS ont des empreintes différentes selon que le paquet est ACK ou 
 SYN+ACK. De manière évidente l'empreinte SYN est plus sure, car le SYN+ACK
 est influencé par la SYN (si un SYN ne contient pas de SACK le SYN+ACK n'en
 contiendra pas non plus même si l'hôte ne supporte). Donc durant la collecte
 d'informations, si nous recevons un SYN+ACK nous enregistrons l'OS de l'hôte
 de manière temporaire et lorsque nous recevrons un SYN nous validerons.
 Les empreintes finissant par un ":A" sont plus surs... c'est la raison pour
 laquelle certaines identifications de systèmes d'exploitations pourraient
 changer durant le processus de validation.

 Les paquets SYN+ACK sont utilisés pour déterminer les ports ouverts de l'hôte.
 (voir section suivante).

 L'aspect intéressant est que les firewalls, les passerelles ou la translation
 d'adresse sont transparents ) la détection passive d'OS. Donc collecter les
 informations à propos du LAN vous permettra de connaître des données 
 concernant même les hôtes distants. Seuls les proxies ne sont pas transparents
 car ils initient de nouvelles connexions vers la cible.

 Notre base de données d'empreinte doit être élargie, donc si vous trouvez un
 hôte ayant une empreinte inconnue et que vous connaissez de manière sûre son
 OS, envoyez-nous par e-mail <alors@users.sourceforge.net> l'empreinte et l'OS,
 nous l'insérerons.


5.5.2 PORTS OUVERTS

 Les ports ouverts sont identifiés en observant les packets SYN+ACK.
 Si un SYN+ACK provient d'un port, il est certainement ouvert, sauf pour
 le canel de commande du protocol FTP, et pour cette raison les paquets depuis 
 le port 20 ne sont pas utilisés.
 Pour les ports UDP le problème est un peu plus complexe car syn et ack
 n'existent pas dans le protocole udp, donc ettercap suppose qu'un port udp 
 < 1024 envoyant des paquets est ouvert. Nous savons que de cette manière nous
 ne pouvont découvrir des ports ouvertes > 1024, mais ils pourraient être
 intéprétés comme ouverts à chaque fois qu'un client envoie des paquets à un
 serveur.


5.5.3 PASSERELLE ET ROUTEURS

 La passerelle est reconnue simplement en regardant les paquets IP avec une
 ip non locale (en vérifiant le masque de sous-réseau). Si une IP non locale
 est trouvée, ettercap regarde l'adresse ethernet (MAC) et la conserve comme
 étant celle de la passerelle, puis il recherche dans la liste l'IP 
 correspondante, qui est celle de la gateway.

 En observant les messages ICMP nous pouvons affirmer que si un hôte envoie
 des messages TTL-exceeded ou redirect, c'est un routeur ou un hôte agissant
 comme tels.

============================================================================
6>                                 PLUG-INs
============================================================================

 reportez vous à README.PLUGINS

============================================================================
7>                          INFORMATONS INUTILES
============================================================================

Début du projet :          25/11/2000

Dernière version stable :  0.6.0       Notre logiciel n'a jamais de bug
                                       Il utilise seulement des fonctionnalités
                                       hasardeuses.

Publié le :                17/09/2001
                                tant qu'un code fonctionne il est obsolète

Editeur :                  vi, vim, gvim, mcedit, UltraEdit

remerciements:             le standard IEEE 802.3 :)
                           l'organisation ISO/OSI
                           Andrew S.Tanenbaum
                           l'université de Berkeley

                           le SiLAB (lab de l'université)
                           JJ's corner PUB

remerciements d'ALoR :     l'équipe de VMWare ;)
                           elle (elle sait pour quoi)
                           Raptor
			   Ma voiture hi-fi
                           Ma nouvelle voiture (Volkswagen Polo 1.4 TDi) wow !

remerciements de NaGA :    Heineken Inc.
                           Mon lecteur MP3
                           N-Team
                           MegaBug

fucks to :                 tutte le tipe che se la menano ;)
                           mcedit (it sucks!)

Slogan :                   la spécialisation, c'est pour les insectes, un
                           homme devrait pouvoir tout faire!

Qui nous sommes :          Si vous pensez que vous nous connaissez... FAUX
                           Si vous ne nous connaissez pas... C'EST POUR BIENTOT

Shakespeare :              question = (to ) ? be: !be;

Traduction :               Julien Bordet ( Bordet_J@yahoo.com )

0xABADC0DE==============================================================EC-2K
